use std::str::FromStr;

use crate::syntax::*;

grammar;

pub Type: GradualType = {
    <dom:TypeAtomic> "->" <cod:Type> => GradualType::fun(dom, cod),
    <TypeAtomic>,
};

TypeAtomic: GradualType = {
    "dyn" => GradualType::Dyn(),
    "?" => GradualType::Dyn(),
    "bool" => GradualType::Base(BaseType::Bool),
    "int" => GradualType::Base(BaseType::Int),
    "(" <Type> ")",
};

TypeAnnot: GradualType = {
    ":" <Type> => <>,
}

pub Expr: SourceExpr = {
    "if" <c:Expr> "then" <t:Expr> "else" <e:Expr> => Expr::if_(c, t, e),
    "\\" <x:Id> <t:TypeAnnot?> "." <e:Expr> => Expr::lam(x, t, e), // TODO multi-argument functions
    "fun" <x:Id> <t:TypeAnnot?> "." <e:Expr> => Expr::lam(x, t, e),
    "let" <x:Id> <t:TypeAnnot?> "=" <e1:Expr> "in" <e2:Expr> => Expr::let_(x, t, e1, e2),
    "let" "rec" <defns:RecDefns> "in" <e2:Expr> => Expr::letrec(defns, e2),
    <ExprAnn>,
};

ExprAnn: SourceExpr = {
    <e:ExprOr> ":" <t:Type> => Expr::ann(e, Some(t)),
    <ExprOr>,
}

ExprOr: SourceExpr = {
    <e1:ExprOr> "||" <e2:ExprAnd> => Expr::bop(SourceBOp::Or, e1, e2),
    <ExprAnd>,
}

ExprAnd: SourceExpr = {
    <e1:ExprAnd> "&&" <e2:ExprCompare> => Expr::bop(SourceBOp::And, e1, e2),
    <ExprCompare>,
}

ExprCompare: SourceExpr = {
    <e1:ExprFactor> "==" <e2:ExprFactor> => Expr::bop(SourceBOp::Equal, e1, e2),
    <e1:ExprFactor> "<" <e2:ExprFactor> => Expr::bop(SourceBOp::LessThan, e1, e2),
    <e1:ExprFactor> ">" <e2:ExprFactor> => Expr::bop(SourceBOp::LessThan, e2, e1),
    <e1:ExprFactor> "<=" <e2:ExprFactor> => Expr::bop(SourceBOp::LessThanEqual, e1, e2),
    <e1:ExprFactor> ">=" <e2:ExprFactor> => Expr::bop(SourceBOp::LessThanEqual, e2, e1),
    <ExprFactor>,
}

ExprFactor: SourceExpr = {
   <e1:ExprFactor> "+" <e2:ExprTerm> => Expr::bop(SourceBOp::Plus, e1, e2),
   <e1:ExprFactor> "-" <e2:ExprTerm> => Expr::bop(SourceBOp::Minus, e1, e2),
   <ExprTerm>,
}

ExprTerm: SourceExpr = {
   <e1:ExprTerm> "*" <e2:ExprApp> => Expr::bop(SourceBOp::Times, e1, e2),
   <e1:ExprTerm> "/" <e2:ExprApp> => Expr::bop(SourceBOp::Divide, e1, e2),
   <ExprApp>,
}

ExprApp: SourceExpr = {
    <e1:ExprApp> <e2:ExprUnary> => Expr::app(e1, e2),
    <ExprUnary>,
};

ExprUnary: SourceExpr = {
    "~" <ExprAtom> => Expr::uop(SourceUOp::Negate, <>),
    "!" <ExprAtom> => Expr::uop(SourceUOp::Not, <>),
    <ExprAtom>,
}

ExprAtom: SourceExpr = {
    <Const>,
    <Id> => Expr::Var(<>),
    "(" <Expr> ")",
};

RecDefns: Vec<(Variable, Option<GradualType>, SourceExpr)> = {
    <v:(<RecDefn> "and")*> <last:RecDefn> => {
        let mut v = v;
        v.push(last);
        v
    }
}

RecDefn: (Variable, Option<GradualType>, SourceExpr) = {
    <Id> <TypeAnnot?> "=" <Expr>
}

Const: SourceExpr = {
    Num => Expr::Const(Constant::Int(<>)),
    Bool => Expr::Const(Constant::Bool(<>)),
};

Num: isize = r"-?[0-9]+" => isize::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

Id: String = <r"[[:alpha:]][[:alnum:]_']*"> => <>.to_string();

match {
    "?",
    "->",
    "(",
    ")",
    "\\",
    ".",
    ":",
    "=",
    "!",
    "~",
    "+",
    "-",
    "*", 
    "/",
    "&&",
    "||",
    "==",
    "<",
    "<=",
    ">",
    ">=",
} else {
    "dyn",
    "bool",
    "int",
    "fun",
    "if",
    "then",
    "else",
    "let",
    "rec",
    "and",
    "in",
    "true",
    "false",
} else {
    r"-?[0-9]+",
    r"[[:alpha:]][[:alnum:]_']*"
}