use std::str::FromStr;

use crate::syntax::*;

grammar;

pub Type: GradualType = {
    <dom:TypeAtomic> "->" <cod:Type> => GradualType::fun(dom, cod),
    <TypeAtomic>,
};

TypeAtomic: GradualType = {
    "dyn" => GradualType::Dyn(),
    "?" => GradualType::Dyn(),
    "bool" => GradualType::Base(BaseType::Bool),
    "int" => GradualType::Base(BaseType::Int),
    "(" <Type> ")",
};

TypeAnnot: GradualType = {
    ":" <Type> => <>,
}

pub Expr: SourceExpr = {
    "if" <c:Expr> "then" <t:Expr> "else" <e:Expr> => Expr::if_(c, t, e),
    "\\" <x:Id> <t:TypeAnnot?> "." <e:Expr> => Expr::lam(x, t, e), // TODO multi-argument functions
    "fun" <x:Id> <t:TypeAnnot?> "." <e:Expr> => Expr::lam(x, t, e),
    "let" <x:Id> <t:TypeAnnot?> "=" <e1:Expr> "in" <e2:Expr> => Expr::let_(x, t, e1, e2),
    "let" "rec" <defns:RecDefns> "in" <e2:Expr> => Expr::letrec(defns, e2),
    <ExprAnn>,
};

ExprAnn: SourceExpr = {
    <e:ExprFactor> ":" <t:Type> => Expr::ann(e, Some(t)),
    <ExprFactor>,
}

ExprFactor: SourceExpr = {
   <e1:ExprFactor> "+" <e2:ExprTerm> => Expr::bop(SourceBOp::Plus, e1, e2),
   <e1:ExprFactor> "-" <e2:ExprTerm> => Expr::bop(SourceBOp::Minus, e1, e2),
   <ExprTerm>,
}

ExprTerm: SourceExpr = {
   <e1:ExprTerm> "*" <e2:ExprApp> => Expr::bop(SourceBOp::Times, e1, e2),
   <e1:ExprTerm> "/" <e2:ExprApp> => Expr::bop(SourceBOp::Divide, e1, e2),
   <ExprApp>,
}

ExprApp: SourceExpr = {
    <e1:ExprApp> <e2:ExprUnary> => Expr::app(e1, e2),
    <ExprUnary>,
};

ExprUnary: SourceExpr = {
    "~" <ExprAtom> => Expr::uop(SourceUOp::Negate, <>),
    "!" <ExprAtom> => Expr::uop(SourceUOp::Not, <>),
    <ExprAtom>,
}

ExprAtom: SourceExpr = {
    <Const>,
    <Id> => Expr::Var(<>),
    "(" <Expr> ")",
};

RecDefns: Vec<(Variable, Option<GradualType>, SourceExpr)> = {
    <v:(<RecDefn> "and")*> <last:RecDefn> => {
        let mut v = v;
        v.push(last);
        v
    }
}

RecDefn: (Variable, Option<GradualType>, SourceExpr) = {
    <Id> <TypeAnnot?> "=" <Expr>
}

Const: SourceExpr = {
    Num => Expr::Const(Constant::Int(<>)),
    Bool => Expr::Const(Constant::Bool(<>)),
};

Num: isize = r"[-?0-9]+" => isize::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

Id: String = <r"[[:alpha:]][[:alnum:]_']*"> => <>.to_string();

match {
    "?",
    "->",
    "(",
    ")",
    "\\",
    ".",
    ":",
    "=",
    "!",
    "~",
    "+",
    "-",
    "*", 
    "/",
    "&&",
    "||",
    "==",
    "<"
} else {
    "dyn",
    "bool",
    "int",
    "fun",
    "if",
    "then",
    "else",
    "let",
    "rec",
    "and",
    "in",
    "true",
    "false",
} else {
    r"[-?0-9]+",
    r"[[:alpha:]][[:alnum:]_']*"
}